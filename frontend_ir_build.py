# CSE423 Compilers
# front_ir_build.py: Builds LLVM from an AST

# Import non-project modules
from treelib import Node, Tree
from llvmlite import ir

# Iterative function to build LLVM representation
def build_llvm(ast):

    assert(ast.get_node(ast.root).tag == "program")

    # Type dictionary used in parsing the AST
    type_dict = {
        "int":    ir.IntType(8),        # Assuming 8 bit ints for now
        "float": ir.DoubleType(),
        "double": ir.DoubleType(),
        "void":   ir.VoidType()
    }

    ir_funcs = {}   # Stores function objects for use when calling functions

    # Create module
    module = ir.Module(name="program")  # Module object stores all program data

    # Iterate through children of root
    for node in ast.children(ast.root):
        if (node.tag.index("func:") == 0):
            # Function definition found
            func_name = node.tag[5:]
            func_return = ""
            func_params = []

            # Iterate through node children to:
            #   Define type
            #   Define params
            #   Find body

            func_body = None    # Used to keep track of the func_body node

            for child in ast.children(node.identifier):
                if (child.tag == "return_type"):
                    func_return = ast.children(child.identifier)[0].tag
                    assert(len(func_return) > 0)

                elif (child.tag == "params"):
                    for param in ast.children(child.identifier):
                        param_type = param.tag
                        param_name = ast.children(param.identifier)[0].tag
                        func_params.append([param_type, param_name])

                elif (child.tag == "func_body"):
                    func_body = child

            assert(func_body is not None)   # Check that we found the func_body

            # Verify that types are known and update from strings to IR type objects
            if (func_return in type_dict):
                func_return = type_dict[func_return]
            else:
                raise Exception("IR Builder Unknown Type: " + func_return)

            for param in func_params:
                if (param[0] in type_dict):
                    param[0] = type_dict[param[0]]
                else:
                    raise Exception("IR Builder Unknown Type: " + param[0])

            # Create function in LLVM
            func_type = ir.FunctionType(
                func_return,                        # Return type
                tuple([p[0] for p in func_params])  # Tuple of param types
            )

            function = ir.Function(module, func_type, name=func_name)
            ir_funcs[func_name] = function          # Store function object by name

            # Build function
            block = function.append_basic_block(name="entry")   # Create function block
            builder = ir.IRBuilder(block)   # Create builder object to work within block

            # FUNCTION IMPLEMENTATION BUILT HERE
            traversal_stack = []    # Used to traverse tree build node_stack
            node_stack = []         # Used to build function. Nodes pushed in level order, popped in reverse level order
            traversal_stack.append(func_body)

            while (len(traversal_stack) > 0):
                iter_node = traversal_stack.pop()   # Get next node from traversal_stack
                node_stack.append(iter_node)        # Add current node to node_stack

                # Add children to the traversal_stack
                for child in ast.children(iter_node.identifier):
                    traversal_stack.append(child)

            # Use reverse level order traversal to build function by popping node_stack
            node_results = {}   # Used to keep track of IR results by node ID (intermediate steps)

            func_locals = {}    # Used to keep track of local variable names by node tag
                # dictionary key (node tag) is the variable's name in the parse tree
                # dictionary value is the variable's name generated by the IR builder

            # Begin reverse level order traversal of parse tree

            bin_ops = ['=', '+', '-', '*', '/', '%', '&&', '||', '<', '>', "<=",
                '>=', '==', '+=', '-=', '*=', '/=', '<<', '>>']
            una_ops = ['++', '--']

            while (len(node_stack) > 0):

                iter_node = node_stack.pop()

                '''
                TO DO:
                - Test unary operations
                - Flow control (if, while)
                - Test variable assignment (=)
                - Constant types other than int or float?
                - Global variables?
                - Nested blocks inside functions
                '''

                if (iter_node.tag == "func_body"):
                    # First node in subtree is just for finding the children
                    # Can be ignored in function building
                    pass
                elif (iter_node.tag in bin_ops):
                    # Binary operation

                    # Get operand node identifiers
                    child_l = ast.children(iter_node.identifier)[0].identifier
                    child_r = ast.children(iter_node.identifier)[1].identifier

                    # Get IR representations of operand nodes
                    operand_l = node_results[child_l]
                    operand_r = node_results[child_r]

                    result = None

                    if (iter_node.tag in ['+=', '-=', '*=', '/=', '%=', '=']):
                        # Local variables only exist in the builder and not the final IR
                        # Values are stored in the func_locals dictionary
                        #   Key = variable name as seen in iter_node.tag
                        #   Value = IR generated result from right hand of assignment
                        var_name = ast.children(iter_node.identifier)[0].tag

                        if (iter_node.tag in ['+=', '-=', '*=', '/=', '%=']):
                            # Get current value of left operand
                            if (var_name in func_locals):
                                operand_l = func_locals[var_name]

                            elif (var_name in [p[1] for p in func_params]):
                                operand_l = function.args[
                                    [p[1] for p in func_params].index(var_name)
                                ]

                            else:
                                raise Exception("IR Builder Unknown Variable: " + var_name)

                            # Evaluate right side operand
                            if (iter_node.tag == '+='):
                                operand_r = builder.fadd(operand_l, operand_r)

                            elif (iter_node.tag == '-='):
                                operand_r = builder.fsub(operand_l, operand_r)

                            elif (iter_node.tag == '*='):
                                operand_r = builder.fmul(operand_l, operand_r)

                            elif (iter_node.tag == '/='):
                                operand_r = builder.fdiv(operand_l, operand_r)

                            elif (iter_node.tag == '%='):
                                operand_r = builder.frem(operand_l, operand_r)

                        # Assign new value where appropriate
                        if (var_name in func_locals):
                            # Assigning new value to existing local variable
                            func_locals[var_name] = operand_r

                        elif (var_name in [p[1] for p in func_params]):
                            # Assigning new value to function parameter
                            # Create "copy" of parameter as local variable
                            func_locals[var_name] = operand_r

                        else:
                            # Defining new local variable
                            func_locals[var_name] = operand_r

                    elif (iter_node.tag == '+'):
                        result = builder.fadd(operand_l, operand_r)

                    elif (iter_node.tag == '-'):
                        result = builder.fsub(operand_l, operand_r)

                    elif (iter_node.tag == '*'):
                        result = builder.fmul(operand_l, operand_r)

                    elif (iter_node.tag == '/'):
                        result = builder.fdiv(operand_l, operand_r)

                    elif (iter_node.tag == '%'):
                        result = builder.frem(operand_l, operand_r)

                    elif (iter_node.tag == '&&'):
                        # Must be implmemented using other operators
                        # (x && y) is equivialent to ((x * y) != 0)
                        step_1 = builder.fmul(operand_l, operand_r)
                        step_2 = ir.Constant(type_dict["int"], 0)
                        result = builder.icmp_signed('!=', step_1, step_2)

                    elif (iter_node.tag == '||'):
                        # Must be implmemented using other operators
                        # (x || y) is equivialent to ((x + y)+(x * y) != 0)
                        step_1 = builder.fadd(operand_l, operand_r)
                        step_2 = builder.fmul(operand_l, operand_r)
                        step_3 = builder.fadd(step_1, step_2)
                        step_4 = ir.Constant(type_dict["int"], 0)
                        result = builder.icmp_signed('!=', step_3, step_4)

                    elif (iter_node.tag in ['<', '>', '<=', '>=', '==', '!=']):
                        result = builder.icmp_signed(iter_node.tag, operand_l, operand_r)
                        # This is the signed comparison.
                        # There's also an unsigned comparison if we care about that

                    elif (iter_node.tag == '<<'):
                        result = builder.shl(operand_l, operand_r)

                    elif (iter_node.tag == '>>'):
                        # Using arithmetic right shift (C/C++ norm) instead of logical shift
                        result = builder.ashr(operand_l, operand_r)

                    assert(result is not None)  # Verify that one of the above cases was satisfied
                    node_results[iter_node.identifier] = result # Store IR result

                elif (iter_node.tag in una_ops):
                    # Unary operation

                    # Get operand node identifiers
                    child = ast.children(iter_node.identifier)[0].identifier
                    # Get IR representations of operand nodes
                    operand = node_results[child]
                    var_name = ast.children(iter_node.identifier)[0].tag

                    result = None

                    # Construct arithmetic statement
                    if (iter_node.tag in ['++', '--']):
                        print("Unary Ops: ++ and -- modify value but act like assignment")

                        # Get current value of left operand
                        if (var_name in func_locals):
                            operand = func_locals[var_name]
                        elif (var_name in [p[1] for p in func_params]):
                            operand = function.args[
                                [p[1] for p in func_params].index(var_name)
                            ]
                        else:
                            assert(False)

                        if (iter_node.tag == '++'):
                            result = builder.fadd(
                                operand,
                                ir.Constant(type_dict["int"], 1)
                            )

                        elif (iter_node.tag == '--'):
                            result = builder.fsub(
                                operand,
                                ir.Constant(type_dict["int"], 1)
                            )

                        assert(result is not None)

                        # Assign new value where appropriate
                        if (var_name in func_locals):
                            # Assigning new value to existing local variable
                            func_locals[var_name] = operand_r

                        elif (var_name in [p[1] for p in func_params]):
                            # Assigning new value to function parameter
                            # Create "copy" of parameter as local variable
                            func_locals[var_name] = operand_r

                        else:
                            # Defining new local variable
                            func_locals[var_name] = operand_r

                    assert(result is not None)  # Verify that one of the above cases was satisfied
                    node_results[iter_node.identifier] = result # Store IR result

                elif (iter_node.tag == 'return'):
                    if (len(ast.children(iter_node.identifier)) == 0):
                        # Void return
                        assert(func_return == type_dict["void"])
                        builder.ret_void()
                    else:
                        # Returning an expression
                        child_id = ast.children(iter_node.identifier)[0].identifier
                        result = node_results[child_id]
                        builder.ret(result)
                
                elif (iter_node.tag == 'condition'):
                    print("TO DO: Handle if-statement")
                    # Expression result is stored in the single child
                
                elif (iter_node.tag == 'condition_body'):
                    print("TO DO: Handle if-statement")
                    # Create a block in which contents are the children in linear order
                
                elif (iter_node.tag == 'if'):
                    print("TO DO: Handle if-statement")
                    # condition is first child, body is second child
                
                elif (iter_node.tag == 'while'):
                    print("TO DO: Handle while-statement")
                    # condition is first child, body is second child

                else:
                    # Node is either a constant, variable ID, or function call
                    if (iter_node.tag in ir_funcs):
                        # Function call
                        arg_list = []
                        for child in ast.children(iter_node.identifier):
                            arg_list.append(node_results[child.identifier])

                        builder.call(ir_funcs[iter_node.tag], arg_list)
                        
                    else:
                        # Constant or variable
                        assert(len(ast.children(iter_node.identifier)) == 0)

                        var_type = ""
                        is_numeral = iter_node.tag.isdigit() # if true, then int

                        if (is_numeral):
                            var_type = "int"
                        else:
                            try:
                                float(iter_node.tag)
                                var_type = "float"
                                is_numeral = True
                            except:
                                pass
                            
                        if (is_numeral):
                            # Constant
                            assert(len(var_type) > 0)
                            assert(type_dict[var_type] is not None)
                            
                            constant = 0
                            if (var_type == "int"):
                                constant = int(iter_node.tag)
                            elif (var_type == "float"):
                                constant = float(iter_node.tag)
                            else:
                                raise Exception("IR Builder Unknown Type: " + var_type)

                            result = ir.Constant(type_dict[var_type], constant)

                        else:
                            # Variable
                            if (iter_node.tag not in [p[1] for p in func_params]):
                                # Local variable

                                # NOTE: Check locals first because arguments
                                # that are changed by assignment are copied to
                                # local variables, so thats where the most up
                                # to date value will be stroed

                                result = func_locals[iter_node.tag]
                            else:
                                # Function argument
                                result = function.args[
                                    [p[1] for p in func_params].index(iter_node.tag)
                                ]

                    node_results[iter_node.identifier] = result

        elif (True):
            print("Handle case for global variables")

    # Return LLVM module
    return module