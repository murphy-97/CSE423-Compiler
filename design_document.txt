=== PROJECT INFO ===============================================================

Members:
  Craig Rasband
  Hannah Murphy
  Morgan Edwards
  Preston Ruff

=== USER GUIDE =================================================================

Usage: python compiler.py -i 'input-file'

  Optional arguments:
  -o       Output file. Requires argument
  -h       Prints usage statement
  --p-scn  Prints scanner output
  --p-prs  Prints parser output
  --p-ir   Prints IR output

Required Modules:
  sys
  getopt
  re
  treelib
  collections
  llvmlite

Project Modules:
  compiler
  frontend
    frontend_scanner
    frontend_parser
    frontend_ir_build
  optimizer
  backend
  errors

=== COMPILER DESIGN ============================================================

SCANNER:
  The scanner takes a file object as a parameter and returns a list of token
  descriptors. Each token descriptor is a list of length 3 containing the token,
  the descriptor or type of the token, and the line number of the token. This
  information is used to generate error messages for unrecognized tokens or is
  passed on to the parser.

PARSER:
  The parser takes the token list generated by the scanner and creates an
  abstract syntax tree from the tokens using a grammar. Once it matches a
  sublist of tokens to a grammar rule, it will either take that token and put it
  into the tree, or it will recursively parse the body of the sublist. The
  compiler uses a collection of helper functions to create new subtrees as
  needed.

IR BUILDER:
  The IR builder performs an level-order traversal of the root's children in the
  abstract syntax tree. Each of these children is either a function definition
  or a global variable. In each function definition, the IR builder performs a
  reverse-level-order traversal of the function's subtree (but without entering
  the subtrees of blocks defined within the function, such as in while-loops).
  Each newly defined scope (such as while-loops and if-statements) is a new
  recursive reverse-level-order traversal of the abstract syntax tree. The IR
  builder adds instructions to blocks, blocks to functions, and functions to the
  overall module that contains the entire IR.

OPTIMIZER:
  The optimizer first performs alternating passes of constant propogation and
  constant folding on each function. Once all functions have reached a stable
  state, the optimizer moves on to remove unused variables. First, it removes
  all "store" instructions for which the stored value is never used (either the
  variable is never loaded, or a new store instruction changes the variable's
  value before it is loaded). Next, any unused "load" instructions are removed.
  If the value into which the variable is loaded is never used, the load
  instruction is removed. Finally, another pass is made to remove an "store"
  instructions rendered unused by the removal of unused load statements. It is
  necessary to remove store statements before and after removing load statements
  to remove unused patterns that would otherwise protect themselves.

ASM BUILDER (BACKEND):
  The ASM builder reads in the IR line by line and checks. Most IR operations
  translate very directly into assembly operations. For these cases, the builder
  checks for the operation and then translates the line. The builder maintains
  a dictionary matching IR variable names to assembly memory addresses (both as
  registers and as stack offsets, depending on the context). For more complex
  code structures, such as comparisons and branches, the ASM builder will pull
  the necessary operations and parameters out of the IR and create more
  complicated multiple-line pieces of code. Function calls are handled by
  placing the first six parameters into passing registers and all remaining
  parameters on the stack and then jumping to the function using assembly's
  "call" operation. The callee function then pulls variables out of registers
  and places them on the stack for use.
  
=== WHAT IS/IS NOT IMPLEMENTED =================================================
  
  SCANNER:
    complete
    
  PARSER:
    Function parsing:               complete
    Expression parsing:             complete
    while statements:               complete
    blocks declared in functions:   complete
    if statements:                  complete
    return statemnts:               complete
    variable declaration:           complete

    function calling:               partial
                                    - Not supported for expressions as
                                      parameters, or function calls as
                                      parameters 
                                    - Function calls only support variables and
                                      constants as parameters. To pass the
                                      result of an expression or another
                                      function call, assign the result to a
                                      variable.

    fuction prototypes:             incomplete 
    else statement:                 incomplete
    for statments:                  incomplete (assumed user will use while)
    ++ --:                          incomplete
  
  IR BUILDER:
    Function parsing:               complete
    Expression parsing:             complete
    while statements:               complete
    blocks declared in functions:   complete
    if statements:                  complete
    return statemnts:               complete
    ++ --:                          complete
    
    variable declaration:           complete

    fuction prototypes:             incomplete
                                    (are they necessary at this stage?)

    else statement:                 incomplete

    for statments:                  incomplete
                                    (would be converted to while by parser)

    function calling:               complete(ish)
                                    - See parser section above for limitations
                                      on function calling

  OPTIMIZER
    Constant Propgation             complete

    Constant Folding                complete (but not independent/pure)
                                    - Folding process relies on some internal
                                      propogation due to limits of the LLVM IR.
                                      It isn't "pure" folding, but it
                                      accomplishes the work of folding plus the
                                      propogation of any values resluting from
                                      folding.

    Removal of unused variables     complete

  ASM BUILDER:
    Complete.
    Limitations on parser and IR builder would not result in new IR patterns
    that the ASM builder would not recognize and handle.

  MISC:
    comments:                       complete(ish)
                                    - Multiple line comments are not counted in
                                      line numbers for error reporting

    error reporting:                partially complete
                                    - Multiple line comments creating line
                                      number reporting errors
                                    - Line number information is not preserved
                                      after parsing

=== KNOWN BUGS & ISSUES ========================================================

- Function parameters cannot be modified via =, +=, -=, etc. This is because of
  the reverse-level-order tree traversal used by the IR builder. The llvmlite
  library does not allow for modifications to be made to function parameters as
  they can be made to global variables (in our implementation of the IR builder,
  llvmlite's global variables are used as a placeholder for local variables).
  However, due to the non-linear traversal of the parse tree used to build the
  IR, the left side of any assignment will reference the initial variable
  associated with the parameter rather than the newly created local variable. If
  we had more time to work on this project, we could devise a new way of
  traversing the parse tree that would be linear with respect to instruction
  order.