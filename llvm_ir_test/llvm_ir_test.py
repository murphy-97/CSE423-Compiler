# CSE423 Compilers
# llvm_ir_test.py: basic test for producing LLVM from an AST

'''
DUMMY C PROGRAM:

int add_int(int x, int y) {
    return x + y;
}

int main(void) {
    int a;
    int b;
    int c;

    a = 1;
    b = 2;
    c = add_int(a, b);

    return 0;
}

'''

# Import non-project modules
from treelib import Node, Tree
from llvmlite import ir

# Iterative function to build LLVM representation
def build_llvm(ast):

    assert(ast.get_node(ast.root).tag == "program")

    # Type dictionary used in parsing the AST
    type_dict = {
        "int":    ir.IntType(8),        # Assuming 8 bit ints for testing
        "double": ir.DoubleType(),
        "void":   ir.VoidType()
    }

    ir_funcs = {}   # Stores function objects for use when calling functions

    # Create module
    module = ir.Module(name="program")  # Module object stores all program data

    # Iterate through children of root
    for node in ast.children(ast.root):
        if (node.tag.index("func:") == 0):
            # Function definition found
            func_name = node.tag[5:]
            func_return = ""
            func_params = []

            # Iterate through node children to:
            #   Define type
            #   Define params
            #   Find body

            func_body = None    # Used to keep track of the func_body node

            for child in ast.children(node.identifier):
                if (child.tag == "return_type"):
                    func_return = ast.children(child.identifier)[0].tag
                    assert(len(func_return) > 0)

                elif (child.tag == "params"):
                    for param in ast.children(child.identifier):
                        param_type = param.tag
                        param_name = ast.children(param.identifier)[0].tag
                        func_params.append([param_type, param_name])

                elif (child.tag == "func_body"):
                    func_body = child

            assert(func_body is not None)   # Check that we found the func_body

            # Verify that types are known and update from strings to IR type objects
            if (func_return in type_dict):
                func_return = type_dict[func_return]
            else:
                raise Exception("Unknown Type: " + func_return)

            for param in func_params:
                if (param[0] in type_dict):
                    param[0] = type_dict[param[0]]
                else:
                    raise Exception("Unknown Type: " + param[0])

            # Create function in LLVM
            func_type = ir.FunctionType(
                func_return,                        # Return type
                tuple([p[0] for p in func_params])  # Tuple of param types
            )

            function = ir.Function(module, func_type, name=func_name)
            ir_funcs[func_name] = function          # Store function object by name

            # Build function
            block = function.append_basic_block(name="entry")   # Create function block
            builder = ir.IRBuilder(block)   # Create builder object to work within block

            # FUNCTION IMPLEMENTATION BUILT HERE
            traversal_stack = []    # Used to traverse tree build node_stack
            node_stack = []         # Used to build function. Nodes pushed in level order, popped in reverse level order
            traversal_stack.append(func_body)

            while (len(traversal_stack) > 0):
                iter_node = traversal_stack.pop()   # Get next node from traversal_stack
                node_stack.append(iter_node)        # Add current node to node_stack

                # Add children to the traversal_stack
                for child in ast.children(iter_node.identifier):
                    traversal_stack.append(child)

            # Use reverse level order traversal to build function by popping node_stack
            node_results = {}   # Used to keep track of IR results by node ID (intermediate steps)

            func_locals = {}    # Used to keep track of local variable names by node tag
                # dictionary key (node tag) is the variable's name in the parse tree
                # dictionary value is the variable's name generated by the IR builder

            # Begin reverse level order traversal of parse tree

            bin_ops = ['=', '+', '-', '*', '/', '%', '&&', '||', '<', '>', "<=",
                '>=', '==']
            una_ops = ['++', '--', '+=', '-=', '*=', '/=', '<<', '>>']

            while (len(node_stack) > 0):

                iter_node = node_stack.pop()

                '''
                TO DO:
                - Unary operations
                - Flow control
                - Test variable assignment (=)
                - Constant types other than int or float?
                - Global variables?
                '''

                if (iter_node.tag == "func_body"):
                    # First node in subtree is just for finding the children
                    # Can be ignored in function building
                    pass
                elif (iter_node.tag in bin_ops):
                    # Binary operation

                    # Get operand node identifiers
                    child_l = ast.children(iter_node.identifier)[0].identifier
                    child_r = ast.children(iter_node.identifier)[1].identifier

                    # Get IR representations of operand nodes
                    operand_l = node_results[child_l]
                    operand_r = node_results[child_r]

                    result = None

                    if (iter_node.tag == '='):
                        # Local variables only exist in the builder and not the final IR
                        # Values are stored in the func_locals dictionary
                        #   Key = variable name as seen in iter_node.tag
                        #   Value = IR generated result from right hand of assignment
                        var_name = ast.children(iter_node.identifier)[0].tag

                        if (iter_node.tag in func_locals):
                            # Assigning new value to existing local variable
                            func_locals[var_name] = operand_r

                        elif (iter_node.tag in [p[1] for p in func_params]):
                            # Assigning new value to function parameter
                            # Create "copy" of parameter as local variable
                            func_locals[var_name] = operand_r

                        else:
                            # Defining new local variable
                            func_locals[var_name] = operand_r

                    elif (iter_node.tag == '+'):
                        result = builder.fadd(operand_l, operand_r)

                    elif (iter_node.tag == '-'):
                        result = builder.fsub(operand_l, operand_r)

                    elif (iter_node.tag == '*'):
                        result = builder.fmul(operand_l, operand_r)

                    elif (iter_node.tag == '/'):
                        result = builder.fdiv(operand_l, operand_r)

                    elif (iter_node.tag == '%'):
                        result = builder.frem(operand_l, operand_r)

                    elif (iter_node.tag == '&&'):
                        # Must be implmemented using other operators
                        # (x && y) is equivialent to ((x * y) != 0)
                        step_1 = builder.fmul(operand_l, operand_r)
                        step_2 = ir.Constant(type_dict["int"], 0)
                        result = builder.icmp_signed('!=', step_1, step_2)

                    elif (iter_node.tag == '||'):
                        # Must be implmemented using other operators
                        # (x || y) is equivialent to ((x + y)+(x * y) != 0)
                        step_1 = builder.fadd(operand_l, operand_r)
                        step_2 = builder.fmul(operand_l, operand_r)
                        step_3 = builder.fadd(step_1, step_2)
                        step_4 = ir.Constant(type_dict["int"], 0)
                        result = builder.icmp_signed('!=', step_3, step_4)

                    elif (iter_node.tag in ['<', '>', '<=', '>=', '==', '!=']):
                        result = builder.icmp_signed(iter_node.tag, operand_l, operand_r)
                        # This is the signed comparison.
                        # There's also an unsigned comparison if we care about that

                    assert(result is not None)  # Verify that one of the above cases was satisfied
                    node_results[iter_node.identifier] = result # Store IR result

                elif (iter_node.tag in una_ops):
                    # Unary operation

                    # Get operand node identifiers
                    child = ast.children(iter_node.identifier)[0].identifier
                    # Get IR representations of operand nodes
                    operand = node_results[child]

                    result = None

                    print("TO DO: Add cases for unary operators")
                    
                    assert(result is not None)  # Verify that one of the above cases was satisfied
                    node_results[iter_node.identifier] = result # Store IR result

                elif (iter_node.tag == 'return'):
                    if (len(ast.children(iter_node.identifier)) == 0):
                        # Void return
                        assert(func_return == type_dict["void"])
                        builder.ret_void()
                    else:
                        # Returning an expression
                        child_id = ast.children(iter_node.identifier)[0].identifier
                        result = node_results[child_id]
                        builder.ret(result)
                else:
                    # Node is either a constant, variable ID, or function call
                    if (iter_node.tag in ir_funcs):
                        # Function call
                        arg_list = []
                        for child in ast.children(iter_node.identifier):
                            arg_list.append(node_results[child.identifier])

                        builder.call(ir_funcs[iter_node.tag], arg_list)
                        
                    else:
                        # Constant or variable
                        assert(len(ast.children(iter_node.identifier)) == 0)

                        var_type = ""
                        is_numeral = iter_node.tag.isdigit() # if true, then int

                        if (is_numeral):
                            var_type = "int"
                        else:
                            try:
                                float(iter_node.tag)
                                var_type = "float"
                                is_numeral = True
                            except:
                                pass
                            
                        if (is_numeral):
                            # Constant
                            assert(len(var_type) > 0)
                            assert(type_dict[var_type] is not None)
                            
                            constant = 0
                            if (var_type == "int"):
                                constant = int(iter_node.tag)
                            elif (var_type == "float"):
                                constant = float(iter_node.tag)
                            else:
                                print("Unaccounted for type")

                            result = ir.Constant(type_dict[var_type], constant)

                        else:
                            # Variable
                            if (iter_node.tag not in [p[1] for p in func_params]):
                                # Local variable

                                # NOTE: Check locals first because arguments
                                # that are changed by assignment are copied to
                                # local variables, so thats where the most up
                                # to date value will be stroed

                                result = func_locals[iter_node.tag]
                            else:
                                # Function argument
                                result = function.args[
                                    [p[1] for p in func_params].index(iter_node.tag)
                                ]

                    node_results[iter_node.identifier] = result

        elif (True):
            print("Handle case for global variables")

    # Return LLVM module
    return module

# Main function: setup sample AST and produce LLVM
def main():

    # Create dummy AST
    ast_dummy = Tree()
    ast_root = Node(tag="program")
    ast_dummy.add_node(ast_root, parent=None)

    # Create nodes for add_int()
    func_root = Node(tag="func:add_int")
    func_type = Node(tag="return_type")
    func_param = Node(tag="params")
    func_body = Node(tag="func_body")

    ast_dummy.add_node(func_root, parent=ast_root)
    ast_dummy.add_node(func_type, parent=func_root)
    ast_dummy.add_node(func_param, parent=func_root)
    ast_dummy.add_node(func_body, parent=func_root)

    ### add_int(): return and params
    return_type = Node(tag="int")
    ast_dummy.add_node(return_type, parent=func_type)

    param_type = Node(tag="int")
    ast_dummy.add_node(param_type, parent=func_param)
    ast_dummy.add_node(Node(tag="x"), parent=param_type)
    param_type = Node(tag="int")
    ast_dummy.add_node(param_type, parent=func_param)
    ast_dummy.add_node(Node(tag="y"), parent=param_type)

    ### add_int(): body
    body_node_0 = Node(tag="return")
    ast_dummy.add_node(body_node_0, parent=func_body)
    body_node_1 = Node(tag="+")
    ast_dummy.add_node(body_node_1, parent=body_node_0)
    body_node_2 = Node(tag="x")
    ast_dummy.add_node(body_node_2, parent=body_node_1)
    body_node_2 = Node(tag="y")
    ast_dummy.add_node(body_node_2, parent=body_node_1)

    # Create nodes for main()
    func_root = Node(tag="func:main")
    func_type = Node(tag="return_type")
    func_param = Node(tag="params")
    func_body = Node(tag="func_body")

    ast_dummy.add_node(func_root, parent=ast_root)
    ast_dummy.add_node(func_type, parent=func_root)
    ast_dummy.add_node(func_param, parent=func_root)
    ast_dummy.add_node(func_body, parent=func_root)

    ### add_int(): return and params
    return_type = Node(tag="int")
    ast_dummy.add_node(return_type, parent=func_type)

    ### add_int(): body
    body_node_0 = Node(tag="return")
    ast_dummy.add_node(body_node_0, parent=func_body)
    body_node_1 = Node(tag="add_int")
    ast_dummy.add_node(body_node_1, parent=body_node_0)
    body_node_2 = Node(tag="1")
    ast_dummy.add_node(body_node_2, parent=body_node_1)
    body_node_2 = Node(tag="2")
    ast_dummy.add_node(body_node_2, parent=body_node_1)

    # Print dummy AST
    print("=== DUMMY AST ===")
    ast_dummy.show(key=lambda x: x.identifier, line_type='ascii')

    # Convert dummy AST into LLVM
    llvm_ir = build_llvm(ast_dummy)

    # Output result
    print("=== LLVM IR OUTPUT ===")
    print(llvm_ir)

# Boilerplate for calling main by running this module
if __name__ == "__main__":
    main()
